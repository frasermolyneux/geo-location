parameters:
  - name: azureSubscription
    type: string
  - name: environment
    type: string
  - name: environmentName
    type: string
  - name: webAppsEnvironment
    type: string
  - name: siteUrl
    type: string

stages:
  - stage: deploy_${{ parameters.environmentName }}
    jobs:
      - deployment: deploy_${{ parameters.environmentName }}
        environment: ${{ parameters.environment }}

        variables:
          - name: SiteUrl
            value: "${{ parameters.siteUrl }}"

        workspace:
          clean: all

        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: Purge soft-deleted APIM (dev only)
                  condition: eq('${{ parameters.environmentName }}', 'dev')
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      $location = $config.parameters.location.value
                      $environment = $config.parameters.environment.value

                      $prefix = "apim-geolocation-$environment-$location-"
                      Write-Host "Checking for soft-deleted APIM instances with prefix '$prefix' in $location..."

                      $subscriptionId = az account show --query id -o tsv
                      $apiVersion = "2021-08-01"

                      # Some CLI versions return 404 when scoping the list by location; use the provider-level list and filter in PowerShell.
                      $deletedResponse = az rest `
                        -m GET `
                        -u "https://management.azure.com/subscriptions/$subscriptionId/providers/Microsoft.ApiManagement/deletedservices?api-version=$apiVersion" `
                        --only-show-errors `
                        -o json

                      if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrWhiteSpace($deletedResponse)) {
                        Write-Host "No soft-deleted APIM instances found for prefix '$prefix'. (lookup returned HTTP $LASTEXITCODE)"
                        $global:LASTEXITCODE = 0
                        return
                      }

                      $deletedServices = $deletedResponse | ConvertFrom-Json

                      # Emit everything we see for debugging
                      Write-Host "Soft-deleted APIM candidates (all locations):"
                      $deletedServices.value | ForEach-Object { Write-Host "- $($_.name) @ $($_.properties.location)" }

                      # Prefer matching prefix, but fall back to any in the same location so we don't miss the blocking instance.
                      $deletedItems = $deletedServices.value `
                        | Where-Object { $_.properties.location -eq $location -and ($_.name -like "$prefix*" -or $true) }

                      $deletedNames = $deletedItems `
                        | Select-Object -ExpandProperty name -ErrorAction SilentlyContinue

                      if (-not $deletedNames) {
                        Write-Host "No soft-deleted APIM instances found for prefix '$prefix'."
                        return
                      }

                      foreach ($item in @($deletedItems)) {
                        $name = $item.name
                        $itemLocation = $item.properties.location

                        Write-Host "Purging soft-deleted APIM '$name' in $itemLocation..."
                        az rest `
                          -m POST `
                          -u "https://management.azure.com/subscriptions/$subscriptionId/providers/Microsoft.ApiManagement/locations/$itemLocation/deletedservices/$name/purge?api-version=$apiVersion" `
                          --only-show-errors `
                          -o json

                        if ($LASTEXITCODE -ne 0) {
                          Write-Warning "Purge call for '$name' returned HTTP $LASTEXITCODE; continuing without failing pipeline."
                          $global:LASTEXITCODE = 0
                        }
                      }

                - task: AzureCLI@2
                  displayName: deploy_${{ parameters.environmentName }}_bicep
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      $deploymentName = "geolocation-${{ parameters.environmentName }}-$($config.parameters.instance.value)"
                      $deletedKeyVaults = az keyvault list-deleted --query '[].properties.vaultId' | ConvertFrom-Json
                      $isDeleted = $deletedKeyVaults | where {$_ -match "rg-geolocation-${{ parameters.environmentName }}-$($config.parameters.location.value)-$($config.parameters.instance.value)"}

                      $keyVaultCreateMode = "default"
                      if ($isDeleted -ne $null) {
                        # To allow the environments to be torn-down and re-created, the Key Vault Create Mode must be set to 'recover'.
                        $keyVaultCreateMode = "recover"
                      }

                      az deployment sub create `
                        --name $deploymentName `
                        --template-file bicep/main.bicep `
                        --location $config.parameters.location.value `
                        --parameters @params/${{ parameters.environmentName }}.json `
                          keyVaultCreateMode=$keyVaultCreateMode

                - task: AzureCLI@2
                  displayName: CreateAppRegistrations
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      . "./scripts/CreateAppRegistration.ps1" `
                          -applicationName "geolocation-api-${{ parameters.environmentName }}-$($config.parameters.instance.value)" `
                          -appRoles "lookup-api-approles.json"

                - task: AzureCLI@2
                  displayName: CreateAppRegistrationsCredentials
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      $deploymentOutput = (az deployment sub show --name "geolocation-$($config.parameters.environment.value)-$($config.parameters.instance.value)") | ConvertFrom-Json

                      . "./scripts/CreateAppRegistrationCredential.ps1" `
                        -keyVaultName $deploymentOutput.properties.outputs.outKeyVaultName.value `
                        -applicationName "geolocation-api-${{ parameters.environmentName }}-$($config.parameters.instance.value)" `
                        -secretPrefix "geolocation-api-${{ parameters.environmentName }}" `
                        -secretDisplayName 'publicwebapp'

                - task: AzureCLI@2
                  name: deploy_outputs
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      $deploymentOutput = (az deployment sub show --name "geolocation-$($config.parameters.environment.value)-$($config.parameters.instance.value)") | ConvertFrom-Json

                      echo "##vso[task.setvariable variable=webAppIdentityPrincipalId]$($deploymentOutput.properties.outputs.webAppIdentityPrincipalId.value)"
                      echo "##vso[task.setvariable variable=webAppName]$($deploymentOutput.properties.outputs.webAppName.value)"
                      echo "##vso[task.setvariable variable=webApiName]$($deploymentOutput.properties.outputs.outWebApiName.value)"

                      echo "##vso[task.setvariable variable=webAppsResourceGroupName]$($deploymentOutput.properties.outputs.outResourceGroupName.value)"

                - task: AzureCLI@2
                  displayName: SetPublicWebAppPermissions
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    scriptType: "pscore"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      $config = (Get-Content params/${{ parameters.environmentName }}.json | ConvertFrom-Json)

                      $apiName = "geolocation-api-$($config.parameters.environment.value)-$($config.parameters.instance.value)"
                      $apiId = (az ad app list --filter "displayName eq '$apiName'" --query '[].appId') | ConvertFrom-Json
                      $resourceId = (az ad sp list --filter "appId eq '$apiId'" --query '[0].id') | ConvertFrom-Json
                      $apiSpn = (az rest -m GET -u https://graph.microsoft.com/v1.0/servicePrincipals/$resourceId) | ConvertFrom-Json
                      $appRoleId = ($apiSpn.appRoles | Where-Object { $_.displayName -eq "LookupApiUser" }).id

                      $deploymentOutput = (az deployment sub show --name "geolocation-$($config.parameters.environment.value)-$($config.parameters.instance.value)") | ConvertFrom-Json

                      $principalId = $deploymentOutput.properties.outputs.webAppIdentityPrincipalId.value
                      . "./scripts/GrantPrincipalAppRole.ps1" -principalId $principalId -resourceId $resourceId -appRoleId $appRoleId

                - download: current
                  artifact: MX.GeoLocation.Api.V1

                - download: current
                  artifact: MX.GeoLocation.Web

                - task: AzureRmWebAppDeployment@4
                  retryCountOnTaskFailure: 3
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    webAppName: $(webApiName)
                    resourceGroupName: $(webAppsResourceGroupName)
                    packageForLinux: "$(Pipeline.Workspace)/MX.GeoLocation.Api.V1/MX.GeoLocation.Api.V1.zip"

                - task: AzureRmWebAppDeployment@4
                  retryCountOnTaskFailure: 3
                  inputs:
                    azureSubscription: ${{ parameters.azureSubscription }}
                    webAppName: $(webAppName)
                    resourceGroupName: $(webAppsResourceGroupName)
                    packageForLinux: "$(Pipeline.Workspace)/MX.GeoLocation.Web/MX.GeoLocation.Web.zip"

      - job: ui_tests_${{ parameters.environmentName }}
        displayName: UI Tests - ${{ parameters.environmentName }}
        dependsOn: deploy_${{ parameters.environmentName }}
        variables:
          SiteUrl: "${{ parameters.siteUrl }}"

        steps:
          - checkout: self

          - pwsh: |
              $maxAttempts = 30  # 5 minutes with 10 second intervals
              $attempt = 0
              $url = "$(SiteUrl)"

              Write-Host "Polling $url until it returns 200 status code..."

              do {
                  $attempt++
                  Write-Host "Attempt $attempt of $maxAttempts..."

                  try {
                      $response = Invoke-WebRequest -Uri $url -Method Get -TimeoutSec 30 -UseBasicParsing
                      if ($response.StatusCode -eq 200) {
                          Write-Host "✅ Site is available! Status code: $($response.StatusCode)"
                          exit 0
                      }
                  }
                  catch {
                      Write-Host "⚠️ Request failed: $($_.Exception.Message)"
                  }

                  if ($attempt -lt $maxAttempts) {
                      Write-Host "Waiting 10 seconds before next attempt..."
                      Start-Sleep -Seconds 10
                  }
              } while ($attempt -lt $maxAttempts)

              Write-Host "❌ Site did not become available within 5 minutes. Continuing with tests anyway..."
            displayName: "Wait for site to be available"

          - task: UseDotNet@2
            displayName: "Use .NET SDK 9.x"
            inputs:
              version: "9.x"

          - task: DotNetCoreCLI@2
            displayName: "Build the project - Release"
            inputs:
              command: "build"
              arguments: "--configuration Release"
              projects: "$(System.DefaultWorkingDirectory)/src/MX.GeoLocation.Web.IntegrationTests/MX.GeoLocation.Web.IntegrationTests.csproj"

          - task: DotNetCoreCLI@2
            displayName: "Install Playwright CLI tool"
            inputs:
              command: 'custom'
              custom: 'tool'
              arguments: 'install --global Microsoft.Playwright.CLI'

          - script: playwright install --with-deps
            displayName: "Install Playwright browsers"
            workingDirectory: "$(System.DefaultWorkingDirectory)/src/MX.GeoLocation.Web.IntegrationTests"

          - pwsh: |
              $maxAttempts = 2
              $attempt = 0
              $exitCode = 1
              $project = Join-Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY "src/MX.GeoLocation.Web.IntegrationTests/MX.GeoLocation.Web.IntegrationTests.csproj"

              if (-not (Test-Path $project)) {
                  Write-Error "Integration test project not found at expected path: $project"
                  exit 1
              }

              Write-Host "Using integration test project: $project"

              do {
                  $attempt++
                  Write-Host "Running UI tests (attempt $attempt of $maxAttempts)..."

                  dotnet test "$project" --no-build --configuration Release
                  $exitCode = $LASTEXITCODE

                  if ($exitCode -eq 0) {
                      Write-Host "UI tests succeeded."
                      break
                  }

                  if ($attempt -lt $maxAttempts) {
                      Write-Host "UI tests failed (exit code $exitCode). Retrying..."
                  }
              } while ($attempt -lt $maxAttempts)

              exit $exitCode
            displayName: "Run UI Tests (with retry)"
